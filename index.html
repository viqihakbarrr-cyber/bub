<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Samurai Predict - Multiplayer</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Shojumaru&family=Roboto:wght@400;700&display=swap');

        :root {
            --bg-url: url('https://raw.githubusercontent.com/viqihakbarrr-cyber/bub/main/Samu/Sbg.jpg');
            --glow-owner: 0 0 20px 5px rgba(0, 191, 255, 0.8);
            --glow-enemy: 0 0 20px 5px rgba(255, 50, 50, 0.8);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
            font-family: 'Roboto', sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-image: var(--bg-url);
            background-size: cover;
            background-position: center;
        }

        /* --- UI LOBBY --- */
        #lobby-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        h1 { font-family: 'Shojumaru', cursive; color: #ffcc00; text-shadow: 2px 2px red; font-size: 2rem; text-align: center; }
        
        .btn {
            background: #8b0000;
            color: white;
            border: 2px solid #ffcc00;
            padding: 10px 20px;
            margin: 10px;
            font-size: 1.2rem;
            cursor: pointer;
            font-family: 'Shojumaru', cursive;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        input {
            padding: 10px;
            font-size: 1.2rem;
            text-align: center;
            letter-spacing: 5px;
            width: 150px;
            background: #222;
            color: white;
            border: 1px solid #555;
        }

        /* --- UI GAMEPLAY --- */
        #game-ui { display: none; width: 100%; height: 100%; }

        /* HUD */
        .hud-bar {
            position: absolute;
            top: 10px;
            width: 40%;
            height: 60px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #hud-left { left: 10px; align-items: flex-start; }
        #hud-right { right: 10px; align-items: flex-end; }

        .bar-container {
            width: 100%;
            height: 20px;
            background: #333;
            border: 1px solid white;
            position: relative;
        }
        .bar-fill { height: 100%; transition: width 0.3s; }
        .hp-fill { background: #00ff00; }
        .kt-fill { background: #00bfff; }
        .label { font-size: 10px; position: absolute; top: -15px; color: #ccc; }

        /* GRID & CHARACTERS */
        #arena {
            position: absolute;
            bottom: 25%; /* Grid position */
            width: 90%;
            left: 5%;
            height: 200px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            /* Debug grid lines (invisible in production as requested) */
            /* border-bottom: 1px solid rgba(255,255,255,0.1); */
        }

        .grid-slot {
            width: 18%; /* 5 grids */
            height: 100%;
            position: relative;
            /* border: 1px dashed rgba(255,255,255,0.1); */
        }

        .character {
            width: 150px; /* Adjust based on sprite size */
            height: 150px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: bottom center;
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            transition: none; /* Instant movement */
        }

        /* Logic Mirroring:
           Owner will always have .owner class (Glow Blue)
           Enemy will always have .enemy class (Glow Red)
        */
        .owner { filter: drop-shadow(var(--glow-owner)); }
        .enemy { filter: drop-shadow(var(--glow-enemy)); transform: translateX(-50%) scaleX(-1); /* Face left */ }

        /* FX */
        #fx-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        .spark {
            width: 200px; height: 200px;
            background-image: url('https://raw.githubusercontent.com/viqihakbarrr-cyber/bub/main/Samu/Spark.png');
            background-size: contain;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 0.1s;
        }
        .spark.active { opacity: 0.8; }

        /* CONTROLS */
        #controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 20;
        }
        .move-btn {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            background: #222;
            border: 2px solid #555;
            color: white;
            font-size: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .move-btn img { width: 30px; height: 30px; margin-bottom: 5px; pointer-events: none; }
        .move-btn.selected { background: #00bfff; border-color: white; color: black; opacity: 0.5; pointer-events: none; }
        .move-btn:active { background: #444; }

        #sequence-display {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            color: yellow;
            font-size: 14px;
            text-shadow: 1px 1px black;
        }
        
        #game-message {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 2rem;
            color: white;
            text-shadow: 0 0 10px black;
            z-index: 60;
            font-family: 'Shojumaru', cursive;
            pointer-events: none;
        }

    </style>
</head>
<body>

<div id="game-container">
    <div id="lobby-screen">
        <h1>SAMURAI PREDICT</h1>
        <div id="lobby-main">
            <button class="btn" onclick="createRoom()">CREATE ROOM</button>
            <br>
            <div style="margin-top:20px; text-align: center;">
                <input type="number" id="room-code-input" placeholder="0000" maxlength="4">
                <br>
                <button class="btn" onclick="joinRoom()">JOIN ROOM</button>
            </div>
            <p id="lobby-status" style="color: cyan; margin-top: 20px;"></p>
        </div>
    </div>

    <div id="game-ui">
        <div class="hud-bar" id="hud-left">
            <span class="label">YOU (HP)</span>
            <div class="bar-container"><div class="bar-fill hp-fill" id="p1-hp" style="width: 100%;"></div></div>
            <span class="label" style="top:25px">KATANA</span>
            <div class="bar-container"><div class="bar-fill kt-fill" id="p1-kt" style="width: 100%;"></div></div>
        </div>

        <div class="hud-bar" id="hud-right">
            <span class="label">ENEMY (HP)</span>
            <div class="bar-container"><div class="bar-fill hp-fill" id="p2-hp" style="width: 100%;"></div></div>
            <span class="label" style="top:25px">KATANA</span>
            <div class="bar-container"><div class="bar-fill kt-fill" id="p2-kt" style="width: 100%;"></div></div>
        </div>

        <div id="arena">
            <div class="grid-slot" id="grid-1"></div>
            <div class="grid-slot" id="grid-2"></div>
            <div class="grid-slot" id="grid-3"></div>
            <div class="grid-slot" id="grid-4"></div>
            <div class="grid-slot" id="grid-5"></div>
        </div>
        
        <div id="fx-layer">
            <div class="spark" id="spark-fx"></div>
        </div>

        <div id="game-message"></div>

        <div id="sequence-display">Urutan: <span id="move-seq-text">...</span></div>
        <div id="controls">
            <button class="move-btn" id="btn-maju" onclick="selectMove('maju')">MAJU</button>
            <button class="move-btn" id="btn-mundur" onclick="selectMove('mundur')">MUNDUR</button>
            <button class="move-btn" id="btn-attack" onclick="selectMove('attack')">ATTACK</button>
            <button class="move-btn" id="btn-tangkis" onclick="selectMove('tangkis')">TANGKIS</button>
        </div>
    </div>
</div>

<script>
    /* --- CONFIG & ASSETS --- */
    const ASSETS = {
        idle: 'https://raw.githubusercontent.com/viqihakbarrr-cyber/bub/main/Samu/Sidle.png',
        maju: 'https://raw.githubusercontent.com/viqihakbarrr-cyber/bub/main/Samu/Smaju.png',
        mundur: 'https://raw.githubusercontent.com/viqihakbarrr-cyber/bub/main/Samu/Smundur.png',
        attack: 'https://raw.githubusercontent.com/viqihakbarrr-cyber/bub/main/Samu/Sattack.png',
        tangkis: 'https://raw.githubusercontent.com/viqihakbarrr-cyber/bub/main/Samu/Stangkis.png'
    };

    /* --- GAME STATE --- */
    let peer;
    let conn;
    let isHost = false;
    let myId = null;
    
    // Stats
    let p1Stats = { hp: 100, katana: 100, pos: 2 }; // Host (Logika: Grid 2)
    let p2Stats = { hp: 100, katana: 100, pos: 4 }; // Client (Logika: Grid 4)
    
    // Turn Logic
    let myMoves = [];
    let enemyMoves = null;
    let turnInProgress = false;

    // DOM Elements
    const lobbyStatus = document.getElementById('lobby-status');
    const msgEl = document.getElementById('game-message');
    const sparkEl = document.getElementById('spark-fx');

    /* --- NETWORK LOGIC (PeerJS) --- */
    function initPeer(id) {
        // Gunakan prefix unik agar tidak bentrok di server public
        peer = new Peer('samu-game-' + id);

        peer.on('open', (id) => {
            myId = id;
            console.log('My ID:', id);
            if(isHost) {
                lobbyStatus.innerText = `Kode Room: ${id.split('-')[2]}`;
                lobbyStatus.style.fontSize = "2rem";
            }
        });

        peer.on('connection', (c) => {
            // Host menerima koneksi
            if (isHost && !conn) {
                conn = c;
                setupConnection();
                startGame();
            }
        });

        peer.on('error', (err) => {
            lobbyStatus.innerText = "Error/Kode Terpakai. Coba lagi.";
            console.error(err);
        });
    }

    function createRoom() {
        const code = Math.floor(1000 + Math.random() * 9000);
        isHost = true;
        initPeer(code);
    }

    function joinRoom() {
        const code = document.getElementById('room-code-input').value;
        if (code.length !== 4) return alert("Masukkan 4 digit kode!");
        
        isHost = false;
        // Kita butuh ID sembarang buat client
        const clientId = Math.floor(10000 + Math.random() * 90000);
        peer = new Peer('samu-client-' + clientId);

        peer.on('open', () => {
            conn = peer.connect('samu-game-' + code);
            setupConnection();
        });
        
        peer.on('error', () => {
            alert("Gagal konek. Cek kode/internet.");
        });
    }

    function setupConnection() {
        conn.on('open', () => {
            console.log("Connected!");
            if(!isHost) startGame(); // Client start UI
        });

        conn.on('data', (data) => {
            handleData(data);
        });
    }

    function handleData(data) {
        if (data.type === 'moves') {
            enemyMoves = data.moves;
            checkTurnReady();
        }
    }

    /* --- GAMEPLAY LOGIC --- */
    function startGame() {
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('game-ui').style.display = 'block';
        resetRoundUI();
        renderCharacters();
    }

    function selectMove(moveType) {
        if (turnInProgress || myMoves.length >= 4) return;
        
        // Cek sudah dipilih belum (Constraint: 1x per tipe)
        if (myMoves.includes(moveType)) return;

        myMoves.push(moveType);
        document.getElementById(`btn-${moveType}`).classList.add('selected');
        updateSequenceText();

        if (myMoves.length === 4) {
            // Send moves to opponent
            conn.send({ type: 'moves', moves: myMoves });
            msgEl.innerText = "MENUNGGU LAWAN...";
            checkTurnReady();
        }
    }

    function updateSequenceText() {
        document.getElementById('move-seq-text').innerText = myMoves.join(" > ").toUpperCase();
    }

    function checkTurnReady() {
        if (myMoves.length === 4 && enemyMoves) {
            msgEl.innerText = "BERTARUNG!";
            turnInProgress = true;
            // Delay 1 detik sebelum animasi mulai
            setTimeout(processCombat, 1000);
        }
    }

    /* --- CORE COMBAT & ANIMATION --- */
    async function processCombat() {
        msgEl.innerText = "";
        
        // Loop 4 langkah
        for (let i = 0; i < 4; i++) {
            let p1Move = isHost ? myMoves[i] : enemyMoves[i];
            let p2Move = isHost ? enemyMoves[i] : myMoves[i];

            // 1. Update Grid/Posisi (Logika)
            updatePositionLogically(p1Move, p2Move);
            
            // 2. Render Animasi & Posisi
            setAnim(true, p1Move); // Host char
            setAnim(false, p2Move); // Client char
            renderCharacters(); // Update visual grid
            
            // 3. Tunggu impact animasi (misal setengah detik) lalu hitung damage
            await wait(500); 

            // 4. Hitung Damage Logic
            calculateDamage(p1Move, p2Move);
            updateHUD();

            // 5. FX jika perlu
            handleFX(p1Move, p2Move);

            // 6. Tunggu sisa durasi (total 3 detik per step menurut prompt, tapi 3 detik terlalu lama, kita buat 1.5 detik per step agar flow enak)
            await wait(1000);

            // Reset ke Idle sebelum step berikutnya
            setAnim(true, 'idle');
            setAnim(false, 'idle');
            await wait(200);

            // Cek mati
            if (p1Stats.hp <= 0 || p2Stats.hp <= 0) break;
        }

        resolveRound();
    }

    function updatePositionLogically(m1, m2) {
        // P1 starts Grid 2. Maju -> +1, Mundur -> -1
        // P2 starts Grid 4. Maju -> -1, Mundur -> +1
        // Grid Limit 1-5.
        
        // Move P1
        if (m1 === 'maju' && p1Stats.pos < 5) p1Stats.pos++;
        if (m1 === 'mundur' && p1Stats.pos > 1) p1Stats.pos--;

        // Move P2
        if (m2 === 'maju' && p2Stats.pos > 1) p2Stats.pos--;
        if (m2 === 'mundur' && p2Stats.pos < 5) p2Stats.pos++;

        // Note: Tidak ada collision logic spesifik di prompt, jadi bisa tembus (overlay).
    }

    function calculateDamage(m1, m2) {
        const dist = Math.abs(p1Stats.pos - p2Stats.pos);
        const isMelee = dist <= 1; // Berdekatan atau satu grid

        // Logic sesuai prompt
        
        // 1. Attack vs Attack
        if (m1 === 'attack' && m2 === 'attack' && isMelee) {
            p1Stats.hp -= 10; p1Stats.katana -= 10;
            p2Stats.hp -= 10; p2Stats.katana -= 10;
        }
        
        // 2. Attack vs Maju/Mundur (Hit)
        else if (m1 === 'attack' && (m2 === 'maju' || m2 === 'mundur') && isMelee) {
            p2Stats.hp -= 20; // P1 Hits P2
        }
        else if (m2 === 'attack' && (m1 === 'maju' || m1 === 'mundur') && isMelee) {
            p1Stats.hp -= 20; // P2 Hits P1
        }

        // 3. Attack vs Tangkis
        else if (m1 === 'attack' && m2 === 'tangkis' && isMelee) {
            p1Stats.katana -= 20; // P1 tumpul
            // Spark handled in visual
        }
        else if (m2 === 'attack' && m1 === 'tangkis' && isMelee) {
            p2Stats.katana -= 20; // P2 tumpul
        }

        // Clamp values
        p1Stats.hp = Math.max(0, p1Stats.hp);
        p2Stats.hp = Math.max(0, p2Stats.hp);
        p1Stats.katana = Math.max(0, p1Stats.katana);
        p2Stats.katana = Math.max(0, p2Stats.katana);
    }

    function handleFX(m1, m2) {
        const dist = Math.abs(p1Stats.pos - p2Stats.pos);
        if (dist > 1) return; // Too far

        // Spark condition: Attack vs Tangkis
        if ((m1 === 'attack' && m2 === 'tangkis') || (m2 === 'attack' && m1 === 'tangkis')) {
            sparkEl.classList.add('active');
            setTimeout(() => sparkEl.classList.remove('active'), 300);
        }
    }

    async function resolveRound() {
        if (p1Stats.hp <= 0 && p2Stats.hp <= 0) {
            msgEl.innerText = "SERI!";
        } else if (p1Stats.hp <= 0) {
            msgEl.innerText = isHost ? "KAMU KALAH!" : "KAMU MENANG!";
        } else if (p2Stats.hp <= 0) {
            msgEl.innerText = isHost ? "KAMU MENANG!" : "KAMU KALAH!";
        } else {
            // Next Round
            msgEl.innerText = "RONDE BERIKUTNYA...";
            await wait(2000);
            resetRoundUI();
            return;
        }
        // Game Over State
        setTimeout(() => location.reload(), 3000);
    }

    function resetRoundUI() {
        myMoves = [];
        enemyMoves = null;
        turnInProgress = false;
        msgEl.innerText = "PILIH KOMBINASI (4)";
        document.getElementById('move-seq-text').innerText = "...";
        
        // Reset buttons
        document.querySelectorAll('.move-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        
        // Reset positions if stuck? No, prompt says "mengulang lagi memilih gerakan". Position persists.
        renderCharacters();
    }

    /* --- RENDERING --- */
    function createCharDOM(isP1) {
        const el = document.createElement('div');
        el.className = isP1 ? 'character owner' : 'character enemy';
        el.id = isP1 ? 'char-p1' : 'char-p2';
        el.style.backgroundImage = `url(${ASSETS.idle})`;
        return el;
    }

    // Initial Render
    const arena = document.getElementById('arena');
    const p1El = createCharDOM(true);
    const p2El = createCharDOM(false);
    // P1 (Owner/Host) always logically leftish, P2 (Enemy) rightish.
    // We append them to the specific Grid Slot DOM
    
    function renderCharacters() {
        // Clear slots
        document.querySelectorAll('.grid-slot').forEach(slot => slot.innerHTML = '');

        // Determine Visual Position based on Perspective
        // Logic:
        // Host View: P1 is Owner (Blue), P2 is Enemy (Red). P1 at Grid X, P2 at Grid Y.
        // Client View: P2 is Owner (Blue), P1 is Enemy (Red). 
        //   BUT Client needs to see Owner on Left. 
        //   So we flip the Grid Index for Client. 
        //   Client's Grid 1 is Logic Grid 5. Client Grid 5 is Logic Grid 1.

        let viewP1Pos, viewP2Pos;

        if (isHost) {
            // Normal 1-5
            viewP1Pos = p1Stats.pos;
            viewP2Pos = p2Stats.pos;
            
            // Append
            document.getElementById(`grid-${viewP1Pos}`).appendChild(p1El);
            document.getElementById(`grid-${viewP2Pos}`).appendChild(p2El);
            
            // Set Visual Styles
            p1El.className = 'character owner'; // Blue
            p2El.className = 'character enemy'; // Red
        } else {
            // Mirrored for Client so Owner (P2) is on Left (Visual Grid 2 usually)
            // Logic Grid 4 (Start P2) -> Visual Grid 2
            // Formula: Visual = 6 - Logic
            viewP1Pos = 6 - p1Stats.pos; 
            viewP2Pos = 6 - p2Stats.pos;

            // In Client view, P2 is the "Owner" (Self)
            document.getElementById(`grid-${viewP2Pos}`).appendChild(p2El); // Self
            document.getElementById(`grid-${viewP1Pos}`).appendChild(p1El); // Enemy

            // Swap Glows for perspective (Self is always Blue/Owner)
            p2El.className = 'character owner'; 
            p1El.className = 'character enemy'; 
        }
    }

    function setAnim(isP1, action) {
        const el = isP1 ? p1El : p2El;
        let url = ASSETS.idle;
        if(action === 'maju') url = ASSETS.maju;
        if(action === 'mundur') url = ASSETS.mundur;
        if(action === 'attack') url = ASSETS.attack;
        if(action === 'tangkis') url = ASSETS.tangkis;
        el.style.backgroundImage = `url(${url})`;
    }

    function updateHUD() {
        // Jika Host: P1 is Left, P2 is Right
        // Jika Client: P2 is Left, P1 is Right
        
        if (isHost) {
            setBar('p1-hp', p1Stats.hp);
            setBar('p1-kt', p1Stats.katana);
            setBar('p2-hp', p2Stats.hp);
            setBar('p2-kt', p2Stats.katana);
        } else {
            setBar('p1-hp', p2Stats.hp); // My HP (P2)
            setBar('p1-kt', p2Stats.katana);
            setBar('p2-hp', p1Stats.hp); // Enemy HP (P1)
            setBar('p2-kt', p1Stats.katana);
        }
    }

    function setBar(id, val) {
        document.getElementById(id).style.width = val + '%';
    }

    function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

</script>
</body>
</html>
